#!/usr/bin/env python
# ssh-auth-id - Authorize SSH public keys from trusted online identities.
# Copyright (c) 2013 Casey Marshall <casey.marshall@gmail.com>
#
# ssh-auth-id is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3.
#
# ssh-auth-id is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with ssh-auth-id.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import os
import stat
import subprocess
from subprocess import Popen
import sys

DEFAULT_PROTO="gh"

parser = argparse.ArgumentParser(description='Authorize SSH public keys from trusted online identities.')
parser.add_argument('-o', '--output', metavar='FILE', help='Write output to file (default ~/.ssh/authorized_keys)')
parser.add_argument('userids', nargs='+', metavar="USERID", help='User IDs to import')
parser.options = None

def die(msg):
	"""The only function worth calling in Perl."""
	print >>sys.stderr, "ERROR: %s" % (msg)
	os._exit(1)

def is_key(fields):
	if not fields:
		return False
	if len(fields) < 3:
		return False
	if not fields[0].startswith('ssh-'):
		return False
	# TODO: decode and validate public key material too?
	return True

def import_keys(proto, username):
	"""
	Import keys from service at 'proto' for 'username',
	appending to output file.
	"""
	# Map out which keys we already have, so we don't keep
	# appending the same ones.
	have_keys = set()
	# Locate output file
	output_file = parser.options.output or os.path.join(
			os.getenv("HOME"), ".ssh", "authorized_keys")
	if os.path.exists(output_file):
		with open(output_file, "r") as f:
			for line in f.readlines():
				fields = line.split()
				if is_key(fields):
					have_keys.add(fields[1])
	elif os.path.dirname(output_file) and not os.path.isdir(os.path.dirname(output_file)):
		die("Parent directory not found for output [%s]" % (output_file))
	# Execute the protocol handler, get the keys from
	# whatever service that maps out to.
	proto_cmd_path = os.path.join(os.path.dirname(sys.argv[0]),
			"%s-%s" % (os.path.basename(sys.argv[0]), proto))
	if not os.path.isfile(proto_cmd_path) or not os.access(proto_cmd_path, os.X_OK):
		die("ssh-auth-id protocol handler %s: not found or cannot execute" % (
				proto_cmd_path))
	proc = Popen([proto_cmd_path, username], stdout=subprocess.PIPE)
	proc_output, _ = proc.communicate(None)
	# Protocol handler should output SSH keys, one per line.
	result = []
	with open(output_file, "a+") as f:
		for line in proc_output.splitlines():
			# Validate/clean-up key text
			line = line.strip()
			fields = line.split()
			if is_key(fields):
				_, key_pub, _ = fields
				if key_pub not in have_keys:
					result.append(fields)
					f.write(" ".join(fields[:3]))
					f.write('\n')
	return result

if __name__ == '__main__':
	parser.options = parser.parse_args()
	keys = []
	for userid in parser.options.userids:
		user_pieces = userid.split(':')
		if len(user_pieces) == 2:
			proto, username = user_pieces
		elif len(user_pieces) == 1:
			proto, username = DEFAULT_PROTO, userid
		else:
			die("Invalid user ID: [%s]" % (userid))
		keys.extend(import_keys(proto, username))
	print >>sys.stderr, "Imported %d keys from %s" % (
		len(keys), ",".join(parser.options.userids))
	os._exit(0)
